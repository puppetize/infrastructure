#!/usr/bin/env ruby

require 'date'
require 'fileutils'
require 'optparse'
require 'tmpdir'
require 'yaml'

class Script < OptionParser
  CONFIG_FILE = '/etc/bacula/bacula-ftp-mirror.yaml'
  CONFIG_OPTIONS = ['host', 'user', 'password', 'local', 'remote',
    'device', 'catalog_db', 'catalog_sql', 'catalog_volume_pattern',
    'bacula_user', 'bacula_group', 'tape_group']

  def initialize
    super

     on '--list', 'List the contents of the FTP server' do
       @action = :list
     end

     on '--sync', 'Synchronize local volumes to the FTP server' do
       @action = :sync
     end

     on '--restore', 'Restore volumes and Bacula catalog from FTP' do
       @action = :restore
     end
   end

   def parse_config!(config_file = CONFIG_FILE)
     config = YAML.load_file config_file
     error = false
     CONFIG_OPTIONS.each do |option|
       if config[option]
         instance_variable_set "@#{option}", config[option]
       else
         $stderr.puts "#{program_name}: missing config option: #{option}"
	 error = true
       end
     end
     exit 1 if error
   end

   def lftp(command)
     IO.popen('lftp -f /dev/stdin', 'w') do |io|
       io.puts 'set ssl:verify-certificate no'
       io.puts "open -u #{@user},#{@password} #{@host}"
       io.puts command
     end
   end

   def do_list
     lftp "ls #{@remote}"
   end

   def do_sync
     lftp "mirror -Re #{@local} #{@remote}"
   end

   def catalog_volumes
     (Dir.entries(@local) - ['.', '..']).select { |volume|
       File.fnmatch @catalog_volume_pattern, volume
     }
   end

   def do_restore
     # Retrieve volumes from the mirror (and delete extra files in the
     # local filesystem).  Afterwards, we need to fix file ownership.
     lftp "mirror -e #{@remote} #{@local}"
     Dir.chdir @local do
       contents = Dir.entries('.') - ['.', '..']
       FileUtils.chown_R @bacula_user, @tape_group, contents
     end

     # Find the volume which contains the most recent catalog backup.
     latest_volume = nil
     latest_timestamp = nil
     IO.popen("bls -V '#{catalog_volumes.join '|'}' #{@device}", 'r') do |io|
       while not io.eof? and line = io.readline
	 if line =~ / Ready to read from volume "([^"]+)"/
	   volume = $1
         elsif volume and line =~ /^bls JobId \d+: .* ([\d-]+ [\d:]+)  ([^\s]+)$/
	   if $2 == @catalog_sql
	     timestamp = DateTime.parse $1
	     if latest_volume.nil? or latest_timestamp < timestamp
	       latest_timestamp = timestamp
	       latest_volume = volume
	     end
	   end
	 end
       end
     end

     if latest_volume.nil?
       $stderr.puts "#{program_name}: no volume found containing #{@catalog_sql}"
       exit 1
     end

     unless system "service bacula-director stop"
       $stderr.puts "#{program_name}: failed to stop bacula-dir!"
       exit 1
     end

     Dir.mktmpdir do |tmpdir|
       puts "Extracting #{@catalog_sql} from volume \"#{latest_volume}\""
       unless system "bextract -V #{latest_volume} #{@device} #{tmpdir} >/dev/null"
         $stderr.puts "#{program_name}: bextract failed!"
	 exit 1
       end
       FileUtils.cp File.join(tmpdir, @catalog_sql), @catalog_sql
     end

     puts "Restoring #{@catalog_db} from #{@catalog_sql}"
     File.unlink @catalog_db if File.exists? @catalog_db
     unless system "sqlite3 #{@catalog_db} < #{@catalog_sql}"
       $stderr.puts "#{program_name}: sqlite3 failed!"
       exit 1
     end
     FileUtils.chown @bacula_user, @bacula_group, @catalog_db

     unless system "service bacula-director start"
       $stderr.puts "#{program_name}: failed to start bacula-dir!"
       exit 1
     end
   end

   def run!
     if ARGV.size != 0
       $stderr.puts "#{program_name}: too many arguments"
       $stderr.puts self
       exit 2
     end

     case @action
     when :list
       do_list
     when :sync
       do_sync
     when :restore
       do_restore
     else
       $stderr.puts "#{program_name}: no action specified"
       $stderr.puts self
       exit 2
     end
   end

   def self.run!
      script = self.new
      script.parse_config!
      script.parse!
      script.run!
   end
end

if $0 == __FILE__
  Script.run!
end
